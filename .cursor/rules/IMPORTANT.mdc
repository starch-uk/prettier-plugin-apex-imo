---
alwaysApply: true
---

# Code Optimization - MANDATORY REFERENCE

**CRITICAL - READ THIS FIRST**: When the user requests optimization (using words like "optimise", "optimize", "refactor", "improve performance", "reduce code size", "clean up code", or any similar request), you MUST:

1. **IMMEDIATELY** read the file `.cursor/plans/OPTIMISE.md` in full before proceeding
2. **STRICTLY** follow all guidelines, strategies, and best practices outlined in that file
3. **USE** that file as your primary and authoritative reference for all optimization work
4. **DO NOT** proceed with optimization work without first reading and understanding the OPTIMISE.md plan

The file `.cursor/plans/OPTIMISE.md` contains comprehensive guidelines, strategies, and best practices for optimizing the codebase while maintaining functionality and code quality. It is the single source of truth for all optimization tasks.

**Trigger keywords/phrases** that require reading OPTIMISE.md:
- "optimise" / "optimize"
- "refactor"
- "improve performance"
- "reduce code size"
- "clean up code"
- "make code more efficient"
- Any request to improve, streamline, or optimize the codebase

# Documentation Update Requirement

**CRITICAL**: When making any changes to the project (including but not limited to):
- Package manager versions (pnpm, npm, etc.)
- Node.js version requirements
- CI/CD workflow configurations
- Dependencies or devDependencies
- Project structure or setup
- Build or test configurations

You MUST update both:
1. **README.md** - Update relevant sections (requirements, installation, usage, etc.)
2. **PLAN.md** - Update all relevant sections including examples, configurations, and workflow definitions

This ensures documentation stays in sync with the actual codebase and prevents confusion for contributors and users.

Refer to documentation files in `docs/*.md`:
- `docs/APEXDOC.md` - ApexDoc quick reference for AI agents
- `docs/ESLINT.md` - ESLint reference and configuration
- `docs/HUSKY9.md` - Husky v9 reference and setup
- `docs/PNPM.md` - pnpm reference and usage
- `docs/VITEST.md` - Vitest reference and configuration

## External Code Inspection

For reference implementation inspection, the following repositories can be checked out to environmental temporary folders:
- **prettier**: https://github.com/prettier/prettier.git
- **prettier-plugin-apex**: https://github.com/dangmai/prettier-plugin-apex.git

These can be cloned to temporary directories for code inspection and reference when implementing features or debugging issues.

# pnpm Command Permissions

**CRITICAL**: When running any `pnpm` commands (including but not limited to `pnpm install`, `pnpm run`, `pnpm test`, `pnpm build`, `pnpm lint`, etc.), you MUST:

1. **ALWAYS** request `required_permissions: ["all"]` to avoid sandbox restrictions
2. **NEVER** run pnpm commands without full permissions as they require file system access, network access, and may need to modify node_modules and other project files
3. pnpm commands should be run with full permissions from the start to prevent sandbox errors and retries

This applies to ALL pnpm commands, not just install commands.

# Test Files Must Use Fixtures

**CRITICAL**: When creating or modifying test files in `tests/*.test.ts`, you MUST:

1. **ALWAYS** use fixtures from `tests/__fixtures__/` for test data instead of inline strings or hardcoded values
2. **ALWAYS** import and use the shared `loadFixture` function from `tests/test-utils.ts` - **NEVER** duplicate the fixture loading code
3. **AVOID** inline test data like `const text = \`/** ... */\`;` - instead create fixture files in `__fixtures__/`
4. **ONLY** use inline test data for:
   - Edge cases that are difficult to represent in fixture files
   - Unit tests that test internal function behavior with mocks (e.g., `annotations.test.ts`, `casing.test.ts`)
   - Tests that require dynamic test data generation

**Fixture Loading Pattern**:
```typescript
import { loadFixture } from './test-utils.js';

// In your test:
const input = loadFixture('apexdoc-single-line-code', 'input');
const expected = loadFixture('apexdoc-single-line-code', 'output');
```

**Test Assertions - Use Exact String Comparisons**:
- **ALWAYS** use `.toBe()` for exact string comparisons instead of `.toContain()` or `.toMatch()`
- **NEVER** use `.toContain()` or `.toMatch()` unless testing for partial matches is absolutely necessary
- Use exact expected values from fixtures or string literals
- Example: `expect(result).toBe(expected)` instead of `expect(result).toContain('some text')`

**Secure File Handling**:
- The shared `loadFixture` function in `tests/test-utils.ts` includes:
  - Fixture name validation (alphanumeric and hyphens only) to prevent directory traversal
  - File parameter validation (only 'input' or 'output')
  - Path resolution checks to ensure paths stay within the test directory
  - Proper error handling with descriptive error messages
- **NEVER** bypass these security checks or create custom fixture loading functions

**When creating new tests**:
- If testing formatting behavior, create fixture files in `tests/__fixtures__/`
- Each fixture should have an `input.cls` and `output.cls` file
- Use descriptive fixture directory names (e.g., `apexdoc-single-line-code`, `annotation-multiple-params`)
- Use exact string comparisons with `.toBe()` for all assertions

This ensures:
- Test data is reusable and maintainable
- Tests are consistent across the codebase
- Test data can be easily inspected and modified
- Integration tests and unit tests follow the same patterns
- Tests are secure and protected against path traversal attacks
- Tests are precise and catch exact formatting differences
